<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation - Abstract Driven Development</title>
    <meta name="description" content="Complete documentation for Abstract Driven Development - principles, patterns, guidelines, and implementation best practices.">
    <meta name="keywords" content="ADD documentation, software architecture documentation, clean architecture guide, dependency inversion guide">

    <!-- Open Graph -->
    <meta property="og:title" content="ADD Documentation">
    <meta property="og:description" content="Complete guide to Abstract Driven Development">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://abstractdriven.com/documentation.html">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/components.css">
    <link rel="stylesheet" href="styles/syntax-highlight.css">

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <a href="/">
                    <i class="fas fa-cube"></i>
                    <span>Abstract Driven</span>
                </a>
            </div>

            <div class="nav-menu" id="nav-menu">
                <ul class="nav-list">
                    <li><a href="index.html#overview" class="nav-link">Overview</a></li>
                    <li><a href="index.html#principles" class="nav-link">Principles</a></li>
                    <li><a href="index.html#patterns" class="nav-link">Patterns</a></li>
                    <li><a href="index.html#examples" class="nav-link">Examples</a></li>
                    <li><a href="documentation.html" class="nav-link active">Docs</a></li>
                    <li><a href="https://github.com/abstractdriven/abstract-driven-playbook" class="nav-link nav-github" target="_blank">
                        <i class="fab fa-github"></i> GitHub
                    </a></li>
                </ul>
            </div>

            <div class="nav-toggle" id="nav-toggle">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <!-- Documentation Header -->
    <section class="docs-header">
        <div class="container">
            <div class="docs-header-content">
                <h1>Documentation</h1>
                <p class="lead">Complete guide to Abstract Driven Development - from core principles to advanced patterns and real-world implementation strategies.</p>
            </div>

            <div class="docs-search">
                <div class="search-box">
                    <i class="fas fa-search"></i>
                    <input type="text" placeholder="Search documentation..." id="docs-search">
                </div>
            </div>
        </div>
    </section>

    <!-- Documentation Navigation -->
    <section class="docs-nav">
        <div class="container">
            <div class="docs-nav-grid">
                <div class="docs-nav-section">
                    <h3><i class="fas fa-rocket"></i> Getting Started</h3>
                    <ul>
                        <li><a href="#introduction">Introduction to ADD</a></li>
                        <li><a href="#quick-start">Quick Start Guide</a></li>
                        <li><a href="#setup">Project Setup</a></li>
                        <li><a href="#first-implementation">First Implementation</a></li>
                    </ul>
                </div>

                <div class="docs-nav-section">
                    <h3><i class="fas fa-lightbulb"></i> Core Principles</h3>
                    <ul>
                        <li><a href="#dependency-inversion">Dependency Inversion Principle</a></li>
                        <li><a href="#layer-separation">Clear Layer Separation</a></li>
                        <li><a href="#technology-independence">Technology Independence</a></li>
                        <li><a href="#simplicity">Simplicity & KISS</a></li>
                    </ul>
                </div>

                <div class="docs-nav-section">
                    <h3><i class="fas fa-puzzle-piece"></i> Patterns & Practices</h3>
                    <ul>
                        <li><a href="#port-adapter">Port & Adapter Pattern</a></li>
                        <li><a href="#dto-mapping">DTO ↔ Entity Mapping</a></li>
                        <li><a href="#event-driven">Event-Driven Communication</a></li>
                        <li><a href="#scope-modules">Scope Modules</a></li>
                        <li><a href="#ruleset-checkpoint">RuleSet + Checkpoint</a></li>
                    </ul>
                </div>

                <div class="docs-nav-section">
                    <h3><i class="fas fa-layer-group"></i> Layer Guidelines</h3>
                    <ul>
                        <li><a href="#boundary-layer">Boundary Layer</a></li>
                        <li><a href="#core-abstractions">Core Abstractions</a></li>
                        <li><a href="#operators-layer">Operators Layer</a></li>
                        <li><a href="#implementations-layer">Implementations Layer</a></li>
                        <li><a href="#bootstrap-layer">Bootstrap Layer</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <!-- Main Documentation Content -->
    <main class="docs-content">
        <div class="container">
            <div class="docs-layout">
                <!-- Sidebar Navigation -->
                <aside class="docs-sidebar">
                    <div class="sidebar-section">
                        <h4>Getting Started</h4>
                        <nav class="sidebar-nav">
                            <a href="#introduction" class="sidebar-link active">Introduction</a>
                            <a href="#quick-start" class="sidebar-link">Quick Start</a>
                            <a href="#setup" class="sidebar-link">Project Setup</a>
                            <a href="#first-implementation" class="sidebar-link">First Implementation</a>
                        </nav>
                    </div>

                    <div class="sidebar-section">
                        <h4>Core Principles</h4>
                        <nav class="sidebar-nav">
                            <a href="#dependency-inversion" class="sidebar-link">Dependency Inversion</a>
                            <a href="#layer-separation" class="sidebar-link">Layer Separation</a>
                            <a href="#technology-independence" class="sidebar-link">Technology Independence</a>
                            <a href="#simplicity" class="sidebar-link">Simplicity</a>
                        </nav>
                    </div>

                    <div class="sidebar-section">
                        <h4>Advanced Theory</h4>
                        <nav class="sidebar-nav">
                            <a href="#advanced-theory" class="sidebar-link">ADD Theory V3</a>
                        </nav>
                    </div>

                    <div class="sidebar-section">
                        <h4>Patterns</h4>
                        <nav class="sidebar-nav">
                            <a href="#port-adapter" class="sidebar-link">Port & Adapter</a>
                            <a href="#dto-mapping" class="sidebar-link">DTO Mapping</a>
                            <a href="#event-driven" class="sidebar-link">Event-Driven</a>
                            <a href="#scope-modules" class="sidebar-link">Scope Modules</a>
                        </nav>
                    </div>

                    <div class="sidebar-section">
                        <h4>Layer Guidelines</h4>
                        <nav class="sidebar-nav">
                            <a href="#boundary-layer" class="sidebar-link">Boundary</a>
                            <a href="#core-abstractions" class="sidebar-link">Core Abstractions</a>
                            <a href="#operators-layer" class="sidebar-link">Operators</a>
                            <a href="#implementations-layer" class="sidebar-link">Implementations</a>
                            <a href="#bootstrap-layer" class="sidebar-link">Bootstrap</a>
                        </nav>
                    </div>
                </aside>

                <!-- Main Content Area -->
                <article class="docs-main">
                    <!-- Introduction Section -->
                    <section id="introduction" class="docs-section">
                        <h1>Introduction to Abstract Driven Development</h1>

                        <div class="alert alert-info">
                            <p><strong>What is ADD?</strong> Abstract Driven Development is a proven 5-layer architecture pattern that prioritizes business logic independence through strategic abstraction and dependency inversion.</p>
                        </div>

                        <h2>The 5 Layers of ADD</h2>

                        <div class="layer-overview-grid">
                            <div class="layer-overview-item">
                                <div class="layer-icon boundary-color">
                                    <i class="fas fa-globe"></i>
                                </div>
                                <h3>Boundary Layer</h3>
                                <p>Handles external communication, data contracts, and protocol translation. Controllers, DTOs, and validation live here.</p>
                            </div>

                            <div class="layer-overview-item">
                                <div class="layer-icon core-color">
                                    <i class="fas fa-heart"></i>
                                </div>
                                <h3>Core Abstractions</h3>
                                <p>Defines business concepts and rules through entities, value objects, ports, and domain events.</p>
                            </div>

                            <div class="layer-overview-item">
                                <div class="layer-icon operators-color">
                                    <i class="fas fa-cogs"></i>
                                </div>
                                <h3>Operators</h3>
                                <p>Orchestrates business workflows, coordinates transactions, and manages use case implementation.</p>
                            </div>

                            <div class="layer-overview-item">
                                <div class="layer-icon implementations-color">
                                    <i class="fas fa-database"></i>
                                </div>
                                <h3>Implementations</h3>
                                <p>Provides concrete implementations of ports, handles external systems, and manages technical concerns.</p>
                            </div>

                            <div class="layer-overview-item">
                                <div class="layer-icon bootstrap-color">
                                    <i class="fas fa-play-circle"></i>
                                </div>
                                <h3>Bootstrap</h3>
                                <p>Configures dependency injection, manages application lifecycle, and wires all layers together.</p>
                            </div>
                        </div>

                        <h2>Key Benefits</h2>

                        <div class="benefits-grid">
                            <div class="benefit-item">
                                <i class="fas fa-shield-alt"></i>
                                <h4>Technology Independence</h4>
                                <p>Business logic remains isolated from specific technologies, enabling easy migration and technology updates.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-vial"></i>
                                <h4>Enhanced Testability</h4>
                                <p>Clean separation allows for comprehensive unit testing with mocks and stubs at every layer.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-expand-arrows-alt"></i>
                                <h4>Improved Scalability</h4>
                                <p>Clear boundaries and loose coupling enable teams to work in parallel and scale independently.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-tools"></i>
                                <h4>Easy Maintenance</h4>
                                <p>Predictable structure and clear responsibilities make debugging and feature updates straightforward.</p>
                            </div>
                        </div>
                    </section>

                    <!-- Quick Start Section -->
                    <section id="quick-start" class="docs-section">
                        <h1>Quick Start Guide</h1>

                        <p>Get up and running with ADD in your project with this step-by-step guide.</p>

                        <h2>1. Project Structure</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">src/
├── boundary/
│   ├── controllers/
│   ├── dtos/
│   └── validation/
├── core/
│   ├── entities/
│   ├── ports/
│   ├── value-objects/
│   └── events/
├── operators/
│   ├── use-cases/
│   └── coordinators/
├── implementations/
│   ├── repositories/
│   ├── services/
│   └── adapters/
└── bootstrap/
    ├── container.ts
    └── app.ts</code></pre>
                        </div>

                        <h2>2. Define Your Domain Entity</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// core/entities/User.ts
export class User {
  constructor(
    public readonly id: UserId,
    public readonly email: Email,
    public readonly fullName: FullName,
    public readonly isActive: boolean
  ) {}

  static create(email: string, fullName: string): User {
    return new User(
      UserId.generate(),
      new Email(email),
      FullName.fromString(fullName),
      true
    );
  }

  deactivate(): User {
    return new User(this.id, this.email, this.fullName, false);
  }
}</code></pre>
                        </div>

                        <h2>3. Create Repository Port</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// core/ports/IUserRepository.ts
export interface IUserRepository {
  save(user: User): Promise&lt;void&gt;;
  findById(id: UserId): Promise&lt;User | null&gt;;
  findByEmail(email: Email): Promise&lt;User | null&gt;;
}</code></pre>
                        </div>

                        <h2>4. Implement Business Logic</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// operators/use-cases/CreateUserOperator.ts
export class CreateUserOperator {
  constructor(
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: CreateUserDto): Promise&lt;UserResponseDto&gt; {
    // Validate business rules
    await this.validateUniqueEmail(dto.email);

    // Create entity
    const user = User.create(dto.email, dto.fullName);

    // Persist
    await this.userRepository.save(user);

    return this.mapToResponseDto(user);
  }
}</code></pre>
                        </div>

                        <div class="alert alert-success">
                            <p><strong>Congratulations!</strong> You've implemented the core ADD pattern. Continue reading to learn about advanced patterns and best practices.</p>
                        </div>
                    </section>

                    <!-- Core Principles Sections -->
                    <section id="dependency-inversion" class="docs-section">
                        <h1>Dependency Inversion Principle</h1>

                        <p>The foundation of Abstract Driven Development is the Dependency Inversion Principle (DIP). This principle ensures that high-level business logic never depends on low-level technical implementations.</p>

                        <h2>The Problem DIP Solves</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// ❌ Bad: Business logic depends on database implementation
class UserService {
  private db = new PostgresDatabase(); // Direct dependency!

  async createUser(email: string): Promise&lt;void&gt; {
    // Business logic mixed with database concerns
    const user = new User(email);
    await this.db.query("INSERT INTO users...", user);
  }
}</code></pre>
                        </div>

                        <h2>The DIP Solution</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// ✅ Good: Business logic depends on abstraction
interface IUserRepository {
  save(user: User): Promise&lt;void&gt;;
}

class UserService {
  constructor(private userRepo: IUserRepository) {} // Injected dependency

  async createUser(email: string): Promise&lt;void&gt; {
    const user = new User(email);
    await this.userRepo.save(user); // Clean business logic
  }
}</code></pre>
                        </div>

                        <div class="alert alert-info">
                            <p><strong>Key Insight:</strong> Both high-level (UserService) and low-level (PostgresUserRepository) modules depend on the abstraction (IUserRepository).</p>
                        </div>
                    </section>

                    <section id="layer-separation" class="docs-section">
                        <h1>Clear Layer Separation</h1>

                        <p>ADD enforces strict boundaries between its 5 layers, with dependencies flowing in only one direction: from outer layers toward inner layers.</p>

                        <h2>The Layer Hierarchy</h2>

                        <div class="layer-overview-grid">
                            <div class="layer-overview-item">
                                <div class="layer-icon boundary-color">1</div>
                                <h3>Boundary</h3>
                                <p>Controllers, DTOs, Validation</p>
                            </div>
                            <div class="layer-overview-item">
                                <div class="layer-icon operators-color">2</div>
                                <h3>Operators</h3>
                                <p>Use Cases, Business Workflows</p>
                            </div>
                            <div class="layer-overview-item">
                                <div class="layer-icon core-color">3</div>
                                <h3>Core Abstractions</h3>
                                <p>Entities, Ports, Business Rules</p>
                            </div>
                            <div class="layer-overview-item">
                                <div class="layer-icon implementations-color">4</div>
                                <h3>Implementations</h3>
                                <p>Database, External APIs</p>
                            </div>
                            <div class="layer-overview-item">
                                <div class="layer-icon bootstrap-color">5</div>
                                <h3>Bootstrap</h3>
                                <p>DI Container, App Setup</p>
                            </div>
                        </div>

                        <div class="alert alert-warning">
                            <p><strong>Rule:</strong> Inner layers should never import from outer layers. Core Abstractions should not know about Operators or Boundary.</p>
                        </div>
                    </section>

                    <section id="technology-independence" class="docs-section">
                        <h1>Technology Independence</h1>

                        <p>Business logic should remain completely isolated from specific technologies, frameworks, or external services. This enables easy migration and reduces vendor lock-in.</p>

                        <h2>Examples of Technology Independence</h2>

                        <div class="benefits-grid">
                            <div class="benefit-item">
                                <i class="fas fa-database"></i>
                                <h4>Database Agnostic</h4>
                                <p>Switch from PostgreSQL to MongoDB without changing business logic</p>
                            </div>
                            <div class="benefit-item">
                                <i class="fas fa-server"></i>
                                <h4>Framework Independence</h4>
                                <p>Move from Express to Fastify without touching core logic</p>
                            </div>
                            <div class="benefit-item">
                                <i class="fas fa-cloud"></i>
                                <h4>Service Flexibility</h4>
                                <p>Replace AWS S3 with Google Cloud Storage easily</p>
                            </div>
                            <div class="benefit-item">
                                <i class="fas fa-envelope"></i>
                                <h4>Vendor Freedom</h4>
                                <p>Switch email providers without code changes</p>
                            </div>
                        </div>
                    </section>

                    <section id="simplicity" class="docs-section">
                        <h1>Simplicity & KISS</h1>

                        <p>Keep It Simple, Stupid (KISS) is crucial for ADD success. The architecture provides powerful abstractions while maintaining simplicity in implementation.</p>

                        <h2>Simplicity Guidelines</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// ✅ Simple and clear
export class User {
  constructor(
    public readonly id: string,
    public readonly email: string
  ) {}

  static create(email: string): User {
    return new User(generateId(), email);
  }
}

// ❌ Over-engineered
export class User extends BaseAggregateRoot implements IUser, IAuditable {
  // Too many abstractions make it complex
}</code></pre>
                        </div>

                        <div class="alert alert-success">
                            <p><strong>Tip:</strong> Start simple and add complexity only when truly needed. Most business logic doesn't require complex patterns.</p>
                        </div>
                    </section>

                    <!-- Project Setup Section -->
                    <section id="setup" class="docs-section">
                        <h1>Project Setup</h1>

                        <p>Set up your project structure to support the ADD 5-layer architecture from the beginning.</p>

                        <h2>Recommended Directory Structure</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">src/
├── boundary/                    # External interfaces
│   ├── controllers/             # HTTP controllers, GraphQL resolvers
│   ├── dtos/                    # Data transfer objects
│   ├── validation/              # Input validation schemas
│   └── events/                  # Boundary events (external)
├── core-abstractions/           # Business abstractions
│   ├── entities/                # Domain entities
│   ├── value-objects/           # Value objects
│   ├── ports/                   # Interface definitions
│   ├── events/                  # Domain events (internal)
│   └── errors/                  # Business exception definitions
├── operators/                   # Business logic orchestration
│   ├── use-cases/               # Primary business operations
│   ├── coordinators/            # Complex workflow orchestration
│   └── mappers/                 # DTO ↔ Entity mapping
├── implementations/             # Technical implementations
│   ├── repositories/            # Data access implementations
│   ├── services/                # External service implementations
│   ├── adapters/                # Third-party integrations
│   └── infrastructure/          # Technical utilities
└── bootstrap/                   # Application composition
    ├── container.ts             # Dependency injection setup
    ├── app.ts                   # Application factory
    └── config/                  # Configuration management</code></pre>
                        </div>

                        <h2>TypeScript Configuration</h2>

                        <div class="code-block">
                            <pre><code class="language-json">// tsconfig.json
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "lib": ["es2020"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "baseUrl": "./src",
    "paths": {
      "@boundary/*": ["boundary/*"],
      "@core/*": ["core-abstractions/*"],
      "@operators/*": ["operators/*"],
      "@implementations/*": ["implementations/*"],
      "@bootstrap/*": ["bootstrap/*"]
    }
  }
}</code></pre>
                        </div>
                    </section>

                    <!-- First Implementation Section -->
                    <section id="first-implementation" class="docs-section">
                        <h1>First Implementation</h1>

                        <p>Build your first feature using the ADD pattern step by step.</p>

                        <h2>Step 1: Define Your Entity</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// core-abstractions/entities/User.ts
import { UserId } from '../value-objects/UserId';
import { Email } from '../value-objects/Email';
import { FullName } from '../value-objects/FullName';

export class User {
  constructor(
    public readonly id: UserId,
    public readonly email: Email,
    public readonly fullName: FullName,
    public readonly isActive: boolean,
    public readonly createdAt: Date
  ) {
    this.validateBusinessRules();
  }

  static create(email: string, fullName: string): User {
    return new User(
      UserId.generate(),
      Email.fromString(email),
      FullName.fromString(fullName),
      true,
      new Date()
    );
  }

  deactivate(): User {
    return new User(
      this.id,
      this.email,
      this.fullName,
      false,
      this.createdAt
    );
  }

  private validateBusinessRules(): void {
    if (!this.email.isValid()) {
      throw new InvalidEmailError(this.email.value);
    }
    if (this.fullName.isEmpty()) {
      throw new EmptyNameError();
    }
  }
}</code></pre>
                        </div>

                        <h2>Step 2: Create Repository Port</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// core-abstractions/ports/IUserRepository.ts
export interface IUserRepository {
  save(user: User): Promise&lt;void&gt;;
  findById(id: UserId): Promise&lt;User | null&gt;;
  findByEmail(email: Email): Promise&lt;User | null&gt;;
  findActiveUsers(): Promise&lt;User[]&gt;;
}

// core-abstractions/ports/IEmailService.ts
export interface IEmailService {
  sendWelcomeEmail(email: Email, userName: string): Promise&lt;void&gt;;
  sendPasswordResetEmail(email: Email, resetToken: string): Promise&lt;void&gt;;
}</code></pre>
                        </div>

                        <h2>Step 3: Implement Business Operator</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// operators/use-cases/CreateUserOperator.ts
export class CreateUserOperator {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly emailService: IEmailService
  ) {}

  async execute(dto: CreateUserDto): Promise&lt;UserResponseDto&gt; {
    // Business validation
    await this.validateUniqueEmail(dto.email);

    // Create entity with business rules
    const user = User.create(dto.email, dto.fullName);

    // Persist through port
    await this.userRepository.save(user);

    // Trigger side effects
    await this.emailService.sendWelcomeEmail(
      user.email,
      user.fullName.value
    );

    // Map to response
    return this.mapToResponseDto(user);
  }

  private async validateUniqueEmail(email: string): Promise&lt;void&gt; {
    const existingUser = await this.userRepository.findByEmail(
      Email.fromString(email)
    );

    if (existingUser) {
      throw new EmailAlreadyExistsError(email);
    }
  }
}</code></pre>
                        </div>

                        <h2>Step 4: Create Concrete Implementation</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// implementations/repositories/PostgresUserRepository.ts
export class PostgresUserRepository implements IUserRepository {
  constructor(private readonly pool: Pool) {}

  async save(user: User): Promise&lt;void&gt; {
    await this.pool.query(
      'INSERT INTO users (id, email, full_name, is_active, created_at) VALUES ($1, $2, $3, $4, $5)',
      [user.id.value, user.email.value, user.fullName.value, user.isActive, user.createdAt]
    );
  }

  async findById(id: UserId): Promise&lt;User | null&gt; {
    const result = await this.pool.query('SELECT * FROM users WHERE id = $1', [id.value]);
    return result.rows.length > 0 ? this.mapRowToUser(result.rows[0]) : null;
  }

  // ... other methods
}</code></pre>
                        </div>

                        <h2>Step 5: Wire Dependencies</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// bootstrap/container.ts
export class Container {
  private static instance: Container;
  private services = new Map();

  static getInstance(): Container {
    if (!Container.instance) {
      Container.instance = new Container();
    }
    return Container.instance;
  }

  register(): void {
    // Implementations
    this.services.set('userRepository', new PostgresUserRepository(dbPool));
    this.services.set('emailService', new SendGridEmailService(apiKey));

    // Operators
    this.services.set('createUserOperator', new CreateUserOperator(
      this.get('userRepository'),
      this.get('emailService')
    ));
  }
}</code></pre>
                        </div>
                    </section>

                    <!-- Advanced Theory Section -->
                    <section id="advanced-theory" class="docs-section">
                        <h1>Advanced Theory</h1>

                        <div class="alert alert-info">
                            <p><strong>ADD Theory V3:</strong> The latest theoretical framework that standardizes roles and establishes clear reference rules between layers.</p>
                        </div>

                        <h2>Goals & Mindset</h2>

                        <div class="benefits-grid">
                            <div class="benefit-item">
                                <i class="fas fa-heart"></i>
                                <h4>Simplicity/KISS</h4>
                                <p>Consistent structure that's easy to apply and understand across teams</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-arrows-alt-h"></i>
                                <h4>DIP-First</h4>
                                <p>Every concrete class depends on abstractions; abstractions never depend on concretes</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-exchange-alt"></i>
                                <h4>Easy Replacement</h4>
                                <p>Separate technology from business logic; swap implementations without affecting operators</p>
                            </div>
                        </div>

                        <h2>Component Types</h2>

                        <div class="layer-overview-grid">
                            <div class="layer-overview-item">
                                <div class="layer-icon core-color">
                                    <i class="fas fa-database"></i>
                                </div>
                                <h3>Data Components</h3>
                                <p><strong>DTOs & Entities:</strong> Fields with validation only. No behavior beyond business rules.</p>
                                <ul>
                                    <li>Transfer data between layers</li>
                                    <li>Enforce business constraints</li>
                                    <li>Immutable by design</li>
                                </ul>
                            </div>

                            <div class="layer-overview-item">
                                <div class="layer-icon operators-color">
                                    <i class="fas fa-cogs"></i>
                                </div>
                                <h3>Action Components</h3>
                                <p><strong>Services/Handlers/Operators:</strong> Coordinate business workflows and orchestrate operations.</p>
                                <ul>
                                    <li>Execute business logic</li>
                                    <li>Coordinate multiple operations</li>
                                    <li>Handle use case scenarios</li>
                                </ul>
                            </div>
                        </div>

                        <h2>Reference Rules Between Layers</h2>

                        <div class="code-block">
                            <pre><code class="language-mermaid">graph BT
  Boundary[Boundary Layer]
  CoreAbstractions[Core Abstractions]
  Operators[Operators Layer]
  Implementations[Implementations]
  Bootstrap[Bootstrap Layer]

  style CoreAbstractions fill:#fff7ed,stroke:#c2410c,stroke-width:2px
  style Boundary fill:#eff6ff,stroke:#1d4ed8,stroke-width:2px

  Operators --> Boundary
  Operators --> CoreAbstractions
  Implementations --> CoreAbstractions
  Bootstrap --> Operators
  Bootstrap --> Implementations</code></pre>
                        </div>

                        <div class="alert alert-warning">
                            <p><strong>Critical Rule:</strong> No direct calls between Operators ↔ Implementations. Communication happens via:</p>
                            <ul>
                                <li>Interfaces declared in Core Abstractions (DI injects Implementation)</li>
                                <li>Internal events (Core Events)</li>
                            </ul>
                        </div>

                        <h2>Events & Data Flow</h2>

                        <h3>Event Types</h3>

                        <div class="benefits-grid">
                            <div class="benefit-item">
                                <i class="fas fa-globe"></i>
                                <h4>Boundary Events</h4>
                                <p>Events at the system edge (input/output). Belong to Boundary layer.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-heart"></i>
                                <h4>Core Events</h4>
                                <p>Internal events between Operators ↔ Implementations. Belong to Core Abstractions.</p>
                            </div>
                        </div>

                        <h3>Processing Flow</h3>

                        <div class="code-block">
                            <pre><code class="language-mermaid">sequenceDiagram
  participant Ext as External System
  participant Boundary
  participant Operators
  participant Core as Core Abstractions
  participant Impl as Implementations

  Ext->>Boundary: Request DTO / Boundary Event
  Boundary->>Operators: DTO
  Operators->>Impl: Call via interface (from Core)
  Impl-->>Operators: Entity/Result
  Operators-->>Boundary: Response DTO / Boundary Event</code></pre>
                        </div>
                    </section>

                    <!-- Port & Adapter Pattern Section -->
                    <section id="port-adapter" class="docs-section">
                        <h1>Port & Adapter Pattern</h1>

                        <div class="alert alert-info">
                            <p><strong>Intent:</strong> Isolate business logic from external systems by defining clear interfaces (ports) and implementing adapters that handle technical integration details.</p>
                        </div>

                        <h2>Problem</h2>

                        <ul>
                            <li>Business logic gets coupled to specific technologies (databases, APIs, messaging systems)</li>
                            <li>Difficult to test business logic without external dependencies</li>
                            <li>Technology changes require modifications throughout the system</li>
                            <li>Different environments need different implementations</li>
                        </ul>

                        <h2>Solution</h2>

                        <p>Define abstract interfaces (ports) in Core Abstractions that express business needs, then implement concrete adapters in Implementations that handle the technical details.</p>

                        <div class="code-block">
                            <pre><code class="language-mermaid">graph TB
    subgraph "Core Abstractions"
        Port[Port - Interface]
    end

    subgraph "Operators"
        Operator[Operator]
    end

    subgraph "Implementations"
        Adapter1[PostgreSQL Adapter]
        Adapter2[MongoDB Adapter]
        Adapter3[In-Memory Adapter]
    end

    subgraph "External Systems"
        DB[(PostgreSQL)]
        Mongo[(MongoDB)]
        Memory[Memory Store]
    end

    Operator --> Port
    Port <|.. Adapter1
    Port <|.. Adapter2
    Port <|.. Adapter3

    Adapter1 --> DB
    Adapter2 --> Mongo
    Adapter3 --> Memory</code></pre>
                        </div>

                        <h2>Complete Implementation Example</h2>

                        <h3>1. Port Definition (Core Abstractions)</h3>

                        <div class="code-block">
                            <pre><code class="language-typescript">// core-abstractions/ports/user.repository.ts
export interface IUserRepository {
  // Business-focused method names
  save(user: User): Promise&lt;void&gt;;
  findById(id: UserId): Promise&lt;User | null&gt;;
  findByEmail(email: Email): Promise&lt;User | null&gt;;
  findActiveUsers(): Promise&lt;User[]&gt;;

  // Business queries, not technical queries
  findUsersRegisteredAfter(date: Date): Promise&lt;User[]&gt;;
  countActiveUsers(): Promise&lt;number&gt;;

  // Bulk operations for business scenarios
  deactivateInactiveUsers(daysSinceLastLogin: number): Promise&lt;number&gt;;
}

// core-abstractions/ports/email.service.ts
export interface IEmailService {
  // Business intent, not implementation details
  sendWelcomeEmail(userEmail: Email, userName: string): Promise&lt;void&gt;;
  sendPasswordResetEmail(userEmail: Email, resetToken: string): Promise&lt;void&gt;;
  sendNotification(userEmail: Email, message: string): Promise&lt;void&gt;;

  // Business validation, not technical validation
  isValidDomain(domain: string): Promise&lt;boolean&gt;;
}</code></pre>
                        </div>

                        <h3>2. Business Operator (Uses Ports)</h3>

                        <div class="code-block">
                            <pre><code class="language-typescript">// operators/use-cases/UserManagementOperator.ts
export class UserManagementOperator {
  constructor(
    private readonly userRepository: IUserRepository,  // Port dependency
    private readonly emailService: IEmailService       // Port dependency
  ) {}

  async registerUser(dto: RegisterUserDto): Promise&lt;UserResponseDto&gt; {
    // Business validation
    await this.validateUniqueEmail(dto.email);

    // Create domain entity
    const user = User.create(dto.email, dto.fullName, dto.password);

    // Persist via port (no knowledge of implementation)
    await this.userRepository.save(user);

    // Send welcome email via port
    await this.emailService.sendWelcomeEmail(user.email, user.fullName.value);

    return this.mapToResponse(user);
  }

  async deactivateInactiveUsers(): Promise&lt;DeactivationSummary&gt; {
    // Business rule: deactivate after 90 days of inactivity
    const deactivatedCount = await this.userRepository.deactivateInactiveUsers(90);

    return {
      deactivatedCount,
      processedAt: new Date()
    };
  }

  // Business logic remains pure and testable
  private async validateUniqueEmail(email: string): Promise&lt;void&gt; {
    const existingUser = await this.userRepository.findByEmail(Email.fromString(email));
    if (existingUser) {
      throw new EmailAlreadyExistsError(email);
    }
  }
}</code></pre>
                        </div>

                        <h3>3. Adapter Implementations</h3>

                        <div class="code-block">
                            <pre><code class="language-typescript">// implementations/repositories/PostgresUserRepository.ts
export class PostgresUserRepository implements IUserRepository {
  constructor(private readonly pool: Pool) {}

  async save(user: User): Promise&lt;void&gt; {
    const query = `
      INSERT INTO users (id, email, full_name, is_active, created_at)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (id) DO UPDATE SET
        email = EXCLUDED.email,
        full_name = EXCLUDED.full_name,
        is_active = EXCLUDED.is_active
    `;

    await this.pool.query(query, [
      user.id.value,
      user.email.value,
      user.fullName.value,
      user.isActive,
      user.createdAt
    ]);
  }

  async findActiveUsers(): Promise&lt;User[]&gt; {
    const result = await this.pool.query(`
      SELECT * FROM users
      WHERE is_active = true
      ORDER BY created_at DESC
    `);

    return result.rows.map(row => this.mapRowToUser(row));
  }

  async deactivateInactiveUsers(daysSinceLastLogin: number): Promise&lt;number&gt; {
    const result = await this.pool.query(`
      UPDATE users
      SET is_active = false, updated_at = NOW()
      WHERE is_active = true
        AND last_login_at < NOW() - INTERVAL '${daysSinceLastLogin} days'
    `);

    return result.rowCount || 0;
  }

  private mapRowToUser(row: any): User {
    return new User(
      new UserId(row.id),
      new Email(row.email),
      FullName.fromString(row.full_name),
      row.is_active,
      new Date(row.created_at)
    );
  }
}

// implementations/services/SendGridEmailService.ts
export class SendGridEmailService implements IEmailService {
  constructor(private readonly apiKey: string) {}

  async sendWelcomeEmail(userEmail: Email, userName: string): Promise&lt;void&gt; {
    const msg = {
      to: userEmail.value,
      from: 'noreply@company.com',
      subject: 'Welcome to Our Platform!',
      html: `&lt;h1&gt;Welcome ${userName}!&lt;/h1&gt;&lt;p&gt;Thank you for joining us.&lt;/p&gt;`
    };

    await sgMail.send(msg);
  }

  async isValidDomain(domain: string): Promise&lt;boolean&gt; {
    // Implementation-specific domain validation logic
    const blockedDomains = ['tempmail.com', '10minutemail.com'];
    return !blockedDomains.includes(domain.toLowerCase());
  }
}</code></pre>
                        </div>

                        <h2>Key Benefits</h2>

                        <div class="benefits-grid">
                            <div class="benefit-item">
                                <i class="fas fa-vial"></i>
                                <h4>Testability</h4>
                                <p>Mock ports easily for unit testing. Test business logic without external dependencies.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-exchange-alt"></i>
                                <h4>Technology Independence</h4>
                                <p>Switch from PostgreSQL to MongoDB by changing adapter registration - no business logic changes.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-layer-group"></i>
                                <h4>Multiple Implementations</h4>
                                <p>Different adapters for different environments: production DB, test in-memory, staging API.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-users"></i>
                                <h4>Team Productivity</h4>
                                <p>Teams can work in parallel: business logic team defines ports, infrastructure team builds adapters.</p>
                            </div>
                        </div>
                    </section>

                    <!-- DTO Entity Mapping Section -->
                    <section id="dto-mapping" class="docs-section">
                        <h1>DTO ↔ Entity Mapping</h1>

                        <div class="alert alert-info">
                            <p><strong>Intent:</strong> Transform data between external contracts (DTOs) and rich internal domain models (Entities) while maintaining clean boundaries and business rule enforcement.</p>
                        </div>

                        <h2>Problem</h2>

                        <ul>
                            <li>External APIs need stable, simple data contracts</li>
                            <li>Internal domain models need rich behavior and business rules</li>
                            <li>Direct exposure of entities breaks encapsulation</li>
                            <li>API changes shouldn't force internal model changes</li>
                        </ul>

                        <h2>Solution</h2>

                        <p>Use Data Transfer Objects (DTOs) for external communication and rich Entities for internal domain logic, with explicit mapping between them in the Operators layer.</p>

                        <div class="code-block">
                            <pre><code class="language-typescript">// Example: Complete DTO ↔ Entity mapping

// boundary/dtos/CreateUserDto.ts
export interface CreateUserDto {
  email: string;
  fullName: string;
  dateOfBirth?: string;  // ISO string for external API
  preferences?: {
    newsletter: boolean;
    theme: 'light' | 'dark';
  };
}

// boundary/dtos/UserResponseDto.ts
export interface UserResponseDto {
  id: string;
  email: string;
  fullName: string;
  isActive: boolean;
  age?: number;  // Calculated field for external consumers
  memberSince: string;  // ISO string
  preferences: {
    newsletter: boolean;
    theme: string;
  };
}

// core-abstractions/entities/User.ts
export class User {
  constructor(
    public readonly id: UserId,
    public readonly email: Email,
    public readonly fullName: FullName,
    public readonly dateOfBirth: DateOfBirth,
    public readonly preferences: UserPreferences,
    public readonly isActive: boolean,
    public readonly createdAt: Date
  ) {
    this.validateBusinessRules();
  }

  // Rich domain behavior
  calculateAge(): number {
    return this.dateOfBirth.getAgeInYears();
  }

  canReceiveNotifications(): boolean {
    return this.isActive && this.preferences.newsletter;
  }

  updatePreferences(newPreferences: Partial&lt;UserPreferences&gt;): User {
    const updatedPreferences = this.preferences.merge(newPreferences);
    return new User(
      this.id,
      this.email,
      this.fullName,
      this.dateOfBirth,
      updatedPreferences,
      this.isActive,
      this.createdAt
    );
  }

  private validateBusinessRules(): void {
    if (this.dateOfBirth.getAgeInYears() < 13) {
      throw new UnderageUserError();
    }
    if (!this.email.isValid()) {
      throw new InvalidEmailError(this.email.value);
    }
  }
}

// operators/mappers/UserMapper.ts
export class UserMapper {
  // DTO → Entity (Input transformation)
  static fromCreateDto(dto: CreateUserDto): User {
    return new User(
      UserId.generate(),
      Email.fromString(dto.email),
      FullName.fromString(dto.fullName),
      dto.dateOfBirth
        ? DateOfBirth.fromISOString(dto.dateOfBirth)
        : DateOfBirth.unknown(),
      UserPreferences.create({
        newsletter: dto.preferences?.newsletter ?? false,
        theme: dto.preferences?.theme ?? 'light'
      }),
      true,
      new Date()
    );
  }

  // Entity → DTO (Output transformation)
  static toResponseDto(user: User): UserResponseDto {
    return {
      id: user.id.value,
      email: user.email.value,
      fullName: user.fullName.value,
      isActive: user.isActive,
      age: user.dateOfBirth.isKnown() ? user.calculateAge() : undefined,
      memberSince: user.createdAt.toISOString(),
      preferences: {
        newsletter: user.preferences.newsletter,
        theme: user.preferences.theme
      }
    };
  }

  // Handle collections efficiently
  static toResponseDtos(users: User[]): UserResponseDto[] {
    return users.map(user => this.toResponseDto(user));
  }
}

// operators/use-cases/UserOperator.ts
export class UserOperator {
  constructor(private readonly userRepository: IUserRepository) {}

  async createUser(dto: CreateUserDto): Promise&lt;UserResponseDto&gt; {
    // Transform DTO to rich Entity
    const user = UserMapper.fromCreateDto(dto);

    // Business logic operates on rich Entity
    await this.validateUniqueEmail(user.email);
    await this.userRepository.save(user);

    // Transform Entity to DTO for external response
    return UserMapper.toResponseDto(user);
  }

  async getUsersByAge(minAge: number, maxAge: number): Promise&lt;UserResponseDto[]&gt; {
    const users = await this.userRepository.findByAgeRange(minAge, maxAge);

    // Business logic: filter out inactive users
    const activeUsers = users.filter(user => user.isActive);

    // Transform collection to DTOs
    return UserMapper.toResponseDtos(activeUsers);
  }
}</code></pre>
                        </div>

                        <h2>Advanced Mapping Patterns</h2>

                        <h3>Conditional Mapping</h3>

                        <div class="code-block">
                            <pre><code class="language-typescript">// Different DTOs for different contexts
export class UserMapper {
  static toPublicDto(user: User): PublicUserDto {
    return {
      id: user.id.value,
      fullName: user.fullName.value,
      memberSince: user.createdAt.toISOString()
      // No email or preferences - public view
    };
  }

  static toAdminDto(user: User): AdminUserDto {
    return {
      id: user.id.value,
      email: user.email.value,
      fullName: user.fullName.value,
      isActive: user.isActive,
      createdAt: user.createdAt.toISOString(),
      lastLoginAt: user.lastLoginAt?.toISOString(),
      preferences: user.preferences.toJson(),
      // Full details for admin
    };
  }
}</code></pre>
                        </div>

                        <h2>Best Practices</h2>

                        <div class="benefits-grid">
                            <div class="benefit-item">
                                <i class="fas fa-exchange-alt"></i>
                                <h4>Explicit Mapping</h4>
                                <p>Always use explicit mapping methods - no auto-mapping libraries that hide transformation logic.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-shield-alt"></i>
                                <h4>Validation Boundaries</h4>
                                <p>Validate DTOs at boundaries, enforce business rules in Entities during mapping.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-layer-group"></i>
                                <h4>Layer Separation</h4>
                                <p>DTOs belong to Boundary, Entities to Core Abstractions, Mapping logic in Operators.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-code"></i>
                                <h4>Type Safety</h4>
                                <p>Use TypeScript strict mode to catch mapping errors at compile time.</p>
                            </div>
                        </div>
                    </section>

                    <!-- Event-Driven Communication Section -->
                    <section id="event-driven" class="docs-section">
                        <h1>Event-Driven Communication</h1>

                        <div class="alert alert-info">
                            <p><strong>Intent:</strong> Enable loose coupling between components by communicating through events rather than direct method calls, supporting both internal coordination and external integration.</p>
                        </div>

                        <h2>Problem</h2>

                        <ul>
                            <li>Direct method calls create tight coupling between components</li>
                            <li>Changes in one component ripple through dependent components</li>
                            <li>Cross-module communication becomes complex and brittle</li>
                            <li>Side effects scattered throughout business logic</li>
                            <li>Difficult to add new functionality without modifying existing code</li>
                        </ul>

                        <h2>Solution</h2>

                        <p>Use events to communicate state changes and trigger side effects, with two distinct event types: <strong>Core Events</strong> for internal communication and <strong>Boundary Events</strong> for external integration.</p>

                        <div class="code-block">
                            <pre><code class="language-mermaid">graph TD
    subgraph "Internal System"
        subgraph "Module A"
            OpA[Operator A]
            CoreEventA[Core Event A]
        end

        subgraph "Module B"
            OpB[Operator B]
            CoreEventB[Core Event B]
        end

        subgraph "Event Bus"
            EventBus[Event Bus]
        end
    end

    subgraph "External Systems"
        ExtSystem1[External System 1]
        ExtSystem2[External System 2]
        BoundaryEvent[Boundary Event]
    end

    OpA --> CoreEventA
    CoreEventA --> EventBus
    EventBus --> OpB
    OpB --> CoreEventB
    CoreEventB --> EventBus

    EventBus --> BoundaryEvent
    BoundaryEvent --> ExtSystem1
    BoundaryEvent --> ExtSystem2</code></pre>
                        </div>

                        <h2>Core Events (Internal Communication)</h2>

                        <h3>Event Definitions</h3>

                        <div class="code-block">
                            <pre><code class="language-typescript">// core-abstractions/events/user.core-events.ts
export abstract class CoreEvent {
  public readonly eventId: string;
  public readonly occurredAt: Date;
  public readonly eventVersion: number;

  constructor(eventVersion: number = 1) {
    this.eventId = crypto.randomUUID();
    this.occurredAt = new Date();
    this.eventVersion = eventVersion;
  }

  abstract get eventType(): string;
}

export class UserRegisteredEvent extends CoreEvent {
  constructor(
    public readonly userId: string,
    public readonly userEmail: string,
    public readonly registrationSource: string
  ) {
    super(1);
  }

  get eventType(): string {
    return 'UserRegistered';
  }
}

export class UserEmailChangedEvent extends CoreEvent {
  constructor(
    public readonly userId: string,
    public readonly oldEmail: string,
    public readonly newEmail: string,
    public readonly changedBy: string
  ) {
    super(1);
  }

  get eventType(): string {
    return 'UserEmailChanged';
  }
}

export class UserDeactivatedEvent extends CoreEvent {
  constructor(
    public readonly userId: string,
    public readonly reason: string,
    public readonly deactivatedBy: string
  ) {
    super(1);
  }

  get eventType(): string {
    return 'UserDeactivated';
  }
}</code></pre>
                        </div>

                        <h3>Event Bus Interface</h3>

                        <div class="code-block">
                            <pre><code class="language-typescript">// core-abstractions/ports/event-bus.ts
export interface IEventBus {
  // Emit events
  emit&lt;T extends CoreEvent&gt;(event: T): Promise&lt;void&gt;;
  emitMany&lt;T extends CoreEvent&gt;(events: T[]): Promise&lt;void&gt;;

  // Subscribe to events
  subscribe&lt;T extends CoreEvent&gt;(
    eventType: new (...args: any[]) =&gt; T,
    handler: EventHandler&lt;T&gt;
  ): void;

  // Unsubscribe
  unsubscribe&lt;T extends CoreEvent&gt;(
    eventType: new (...args: any[]) =&gt; T,
    handler: EventHandler&lt;T&gt;
  ): void;
}

export type EventHandler&lt;T extends CoreEvent&gt; = (event: T) =&gt; Promise&lt;void&gt;;

// Specialized handlers for common scenarios
export interface IEventHandler {
  canHandle(event: CoreEvent): boolean;
  handle(event: CoreEvent): Promise&lt;void&gt;;
}</code></pre>
                        </div>

                        <h3>Event-Aware Operator</h3>

                        <div class="code-block">
                            <pre><code class="language-typescript">// operators/user/UserManagementOperator.ts
export class UserManagementOperator {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly emailService: IEmailService,
    private readonly eventBus: IEventBus
  ) {}

  async registerUser(dto: RegisterUserDto): Promise&lt;UserResponseDto&gt; {
    // Business logic
    const user = User.create(dto.email, dto.fullName);
    await this.userRepository.save(user);

    // Send welcome email
    await this.emailService.sendWelcomeEmail(user.email, user.fullName.value);

    // Emit event for other modules to react
    await this.eventBus.emit(new UserRegisteredEvent(
      user.id.value,
      user.email.value,
      dto.registrationSource
    ));

    return UserMapper.toResponseDto(user);
  }

  async changeUserEmail(userId: string, newEmail: string, changedBy: string): Promise&lt;void&gt; {
    const user = await this.userRepository.findById(new UserId(userId));
    if (!user) {
      throw new UserNotFoundError(userId);
    }

    const oldEmail = user.email.value;
    const updatedUser = user.changeEmail(new Email(newEmail));

    await this.userRepository.save(updatedUser);

    // Emit event for audit logging, notification, etc.
    await this.eventBus.emit(new UserEmailChangedEvent(
      userId,
      oldEmail,
      newEmail,
      changedBy
    ));
  }
}</code></pre>
                        </div>

                        <h2>Event Handlers</h2>

                        <h3>Notification Handler</h3>

                        <div class="code-block">
                            <pre><code class="language-typescript">// operators/notifications/NotificationHandler.ts
export class NotificationHandler implements IEventHandler {
  constructor(
    private readonly notificationService: INotificationService,
    private readonly userRepository: IUserRepository
  ) {}

  canHandle(event: CoreEvent): boolean {
    return event instanceof UserRegisteredEvent ||
           event instanceof UserEmailChangedEvent ||
           event instanceof UserDeactivatedEvent;
  }

  async handle(event: CoreEvent): Promise&lt;void&gt; {
    if (event instanceof UserRegisteredEvent) {
      await this.handleUserRegistered(event);
    } else if (event instanceof UserEmailChangedEvent) {
      await this.handleUserEmailChanged(event);
    } else if (event instanceof UserDeactivatedEvent) {
      await this.handleUserDeactivated(event);
    }
  }

  private async handleUserRegistered(event: UserRegisteredEvent): Promise&lt;void&gt; {
    // Send notification to admin
    await this.notificationService.notifyAdmin({
      type: 'user-registered',
      message: `New user registered: ${event.userEmail}`,
      userId: event.userId,
      source: event.registrationSource
    });

    // Track registration metrics
    await this.trackUserRegistration(event);
  }

  private async handleUserEmailChanged(event: UserEmailChangedEvent): Promise&lt;void&gt; {
    // Send security notification to user
    await this.notificationService.sendSecurityAlert({
      userId: event.userId,
      message: 'Your email address has been changed',
      newEmail: event.newEmail,
      changedBy: event.changedBy
    });
  }

  private async handleUserDeactivated(event: UserDeactivatedEvent): Promise&lt;void&gt; {
    // Clean up user sessions, revoke tokens, etc.
    await this.cleanupUserSessions(event.userId);
  }
}</code></pre>
                        </div>

                        <h3>Audit Handler</h3>

                        <div class="code-block">
                            <pre><code class="language-typescript">// operators/audit/AuditHandler.ts
export class AuditHandler implements IEventHandler {
  constructor(private readonly auditRepository: IAuditRepository) {}

  canHandle(event: CoreEvent): boolean {
    // Handle all events for auditing
    return true;
  }

  async handle(event: CoreEvent): Promise&lt;void&gt; {
    const auditEntry = new AuditEntry({
      eventId: event.eventId,
      eventType: event.eventType,
      occurredAt: event.occurredAt,
      eventData: JSON.stringify(event),
      version: event.eventVersion
    });

    await this.auditRepository.save(auditEntry);
  }
}</code></pre>
                        </div>

                        <h2>Boundary Events (External Integration)</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// boundary/events/user.boundary-events.ts
export abstract class BoundaryEvent {
  public readonly eventId: string;
  public readonly occurredAt: Date;

  constructor() {
    this.eventId = crypto.randomUUID();
    this.occurredAt = new Date();
  }

  abstract get eventType(): string;
  abstract toExternalFormat(): any;
}

export class UserRegisteredBoundaryEvent extends BoundaryEvent {
  constructor(
    public readonly userId: string,
    public readonly userEmail: string,
    public readonly registrationDate: Date
  ) {
    super();
  }

  get eventType(): string {
    return 'user.registered';
  }

  toExternalFormat(): any {
    return {
      event_type: this.eventType,
      event_id: this.eventId,
      occurred_at: this.occurredAt.toISOString(),
      data: {
        user_id: this.userId,
        email: this.userEmail,
        registration_date: this.registrationDate.toISOString()
      }
    };
  }
}

// boundary/adapters/WebhookEventPublisher.ts
export class WebhookEventPublisher {
  constructor(private readonly httpClient: IHttpClient) {}

  async publishEvent(event: BoundaryEvent): Promise&lt;void&gt; {
    const payload = event.toExternalFormat();

    await this.httpClient.post('/webhooks/events', {
      body: payload,
      headers: {
        'Content-Type': 'application/json',
        'X-Event-Type': event.eventType
      }
    });
  }
}</code></pre>
                        </div>

                        <h2>Event Bus Implementation</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// implementations/event-bus/InMemoryEventBus.ts
export class InMemoryEventBus implements IEventBus {
  private handlers = new Map&lt;string, EventHandler&lt;any&gt;[]&gt;();

  async emit&lt;T extends CoreEvent&gt;(event: T): Promise&lt;void&gt; {
    const eventType = event.constructor.name;
    const handlersForEvent = this.handlers.get(eventType) || [];

    // Execute all handlers in parallel
    await Promise.all(
      handlersForEvent.map(handler =&gt; this.safeExecuteHandler(handler, event))
    );
  }

  async emitMany&lt;T extends CoreEvent&gt;(events: T[]): Promise&lt;void&gt; {
    await Promise.all(events.map(event =&gt; this.emit(event)));
  }

  subscribe&lt;T extends CoreEvent&gt;(
    eventType: new (...args: any[]) =&gt; T,
    handler: EventHandler&lt;T&gt;
  ): void {
    const typeName = eventType.name;

    if (!this.handlers.has(typeName)) {
      this.handlers.set(typeName, []);
    }

    this.handlers.get(typeName)!.push(handler);
  }

  unsubscribe&lt;T extends CoreEvent&gt;(
    eventType: new (...args: any[]) =&gt; T,
    handler: EventHandler&lt;T&gt;
  ): void {
    const typeName = eventType.name;
    const handlersForType = this.handlers.get(typeName);

    if (handlersForType) {
      const index = handlersForType.indexOf(handler);
      if (index !== -1) {
        handlersForType.splice(index, 1);
      }
    }
  }

  private async safeExecuteHandler&lt;T extends CoreEvent&gt;(
    handler: EventHandler&lt;T&gt;,
    event: T
  ): Promise&lt;void&gt; {
    try {
      await handler(event);
    } catch (error) {
      // Log error but don't fail entire event processing
      console.error(`Event handler failed for ${event.eventType}:`, error);
    }
  }
}</code></pre>
                        </div>

                        <h2>Bootstrap Integration</h2>

                        <div class="code-block">
                            <pre><code class="language-typescript">// bootstrap/EventBootstrap.ts
export class EventBootstrap {
  static setupEventHandlers(
    eventBus: IEventBus,
    container: Container
  ): void {
    // Register event handlers
    const notificationHandler = container.get&lt;NotificationHandler&gt;('notificationHandler');
    const auditHandler = container.get&lt;AuditHandler&gt;('auditHandler');

    // Subscribe to events
    eventBus.subscribe(UserRegisteredEvent, (event) =&gt;
      notificationHandler.handle(event)
    );

    eventBus.subscribe(UserEmailChangedEvent, (event) =&gt;
      notificationHandler.handle(event)
    );

    eventBus.subscribe(UserDeactivatedEvent, (event) =&gt;
      notificationHandler.handle(event)
    );

    // Audit all events
    [UserRegisteredEvent, UserEmailChangedEvent, UserDeactivatedEvent].forEach(eventType =&gt; {
      eventBus.subscribe(eventType, (event) =&gt; auditHandler.handle(event));
    });
  }
}</code></pre>
                        </div>

                        <h2>Key Benefits</h2>

                        <div class="benefits-grid">
                            <div class="benefit-item">
                                <i class="fas fa-unlink"></i>
                                <h4>Loose Coupling</h4>
                                <p>Components don't know about each other directly - they only know about events.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-plus-circle"></i>
                                <h4>Easy Extension</h4>
                                <p>Add new functionality by subscribing to existing events without changing existing code.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-layer-group"></i>
                                <h4>Cross-Module Communication</h4>
                                <p>Modules can communicate without direct dependencies through the event bus.</p>
                            </div>

                            <div class="benefit-item">
                                <i class="fas fa-vial"></i>
                                <h4>Testability</h4>
                                <p>Mock event bus for testing, verify events are emitted correctly.</p>
                            </div>
                        </div>

                        <h2>Best Practices</h2>

                        <div class="alert alert-success">
                            <h4>Event Design Guidelines:</h4>
                            <ul>
                                <li><strong>Past Tense:</strong> Name events in past tense (UserRegistered, not RegisterUser)</li>
                                <li><strong>Immutable:</strong> Events should be immutable once created</li>
                                <li><strong>Rich Data:</strong> Include all necessary data - avoid requiring additional lookups</li>
                                <li><strong>Versioning:</strong> Include version numbers for event evolution</li>
                                <li><strong>Error Handling:</strong> Handle event processing failures gracefully</li>
                            </ul>
                        </div>
                    </section>

                    <!-- Navigation to other sections -->
                    <section class="docs-navigation">
                        <div class="docs-nav-buttons">
                            <a href="#introduction" class="btn btn-secondary">
                                <i class="fas fa-arrow-left"></i> Back to Top
                            </a>
                            <a href="index.html" class="btn btn-primary">
                                Return to Homepage <i class="fas fa-home"></i>
                            </a>
                        </div>
                    </section>
                </article>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-cube"></i> Abstract Driven Development</h4>
                    <p>A proven architecture pattern for building maintainable, testable, and scalable software systems.</p>
                    <div class="footer-social">
                        <a href="https://github.com/abstractdriven/abstract-driven-playbook" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                        <a href="https://twitter.com/abstractdriven" target="_blank">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="https://linkedin.com/company/abstractdriven" target="_blank">
                            <i class="fab fa-linkedin"></i>
                        </a>
                    </div>
                </div>

                <div class="footer-section">
                    <h5>Documentation</h5>
                    <ul>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#quick-start">Quick Start</a></li>
                        <li><a href="#principles">Principles</a></li>
                        <li><a href="#patterns">Patterns</a></li>
                        <li><a href="#examples">Examples</a></li>
                    </ul>
                </div>

                <div class="footer-section">
                    <h5>Resources</h5>
                    <ul>
                        <li><a href="https://github.com/abstractdriven/abstract-driven-playbook/tree/main/examples">Code Examples</a></li>
                        <li><a href="https://github.com/abstractdriven/abstract-driven-playbook/tree/main/patterns">Patterns</a></li>
                        <li><a href="https://github.com/abstractdriven/abstract-driven-playbook/tree/main/theories">Theory</a></li>
                        <li><a href="https://github.com/abstractdriven/abstract-driven-playbook/issues">Support</a></li>
                    </ul>
                </div>

                <div class="footer-section">
                    <h5>Community</h5>
                    <ul>
                        <li><a href="https://github.com/abstractdriven/abstract-driven-playbook/discussions">Discussions</a></li>
                        <li><a href="https://github.com/abstractdriven/abstract-driven-playbook/issues">Issues</a></li>
                        <li><a href="https://github.com/abstractdriven/abstract-driven-playbook/blob/main/CONTRIBUTING.md">Contributing</a></li>
                        <li><a href="https://github.com/abstractdriven/abstract-driven-playbook/blob/main/CODE_OF_CONDUCT.md">Code of Conduct</a></li>
                    </ul>
                </div>
            </div>

            <div class="footer-bottom">
                <p>&copy; 2024 Abstract Driven Development. Open source under MIT License.</p>
                <p>Built with ADD principles - <a href="https://github.com/abstractdriven/abstract-driven-playbook">View Source</a></p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/main.js"></script>
    <script src="js/syntax-highlight.js"></script>
</body>
</html>