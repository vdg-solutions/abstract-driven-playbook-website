# Abstract Driven Development (A.D.D) V3 - Theory & Principles

**Version**: 3.2.0
**Last Updated**: October 21, 2025

---

A.D.D is a software architecture methodology built on Dependency Inversion Principle (DIP), emphasizing simplicity, consistency, and technology replaceability through strict layered structure.

## Core Philosophy

### Goals
- **Simplicity/KISS**: Consistent structure, easy to apply across projects
- **DIP-first**: Every concrete class depends on abstractions; abstractions never depend on concretes
- **Easy replacement**: Technology changes don't affect business logic; swap implementations freely

### Fundamental Rule
**Operators never call Implementations directly.** All communication goes through interfaces (Ports) declared in Core Abstractions, wired via Dependency Injection.

## The 5-Layer Architecture

### 1. Boundary
**Role**: System ingress/egress
**Contains**:
- DTOs (Data Transfer Objects) - external data contracts
- Boundary Events - events crossing system boundary
- Public service contracts (API endpoints, CLI commands, webhooks)
- Input validation

**Dependencies**: None (or minimal framework dependencies)
**Purpose**: Define what the system exposes to the outside world

### 2. Core Abstractions
**Role**: Internal contracts and domain models
**Contains**:
- Entities - thin data structures with validation only
- Ports (Interfaces) - contracts for repositories, services, gateways
- Core Events - internal events for Operators↔Implementations communication
- Domain models - business concepts

**Dependencies**: None
**Purpose**: Abstract away all implementation details; define "what" not "how"

### 3. Operators
**Role**: Business orchestration
**Contains**:
- Business workflows and coordination logic
- DTO↔Entity mapping
- Business rule execution (via RuleSets in Extended)
- Calls to Ports only (never concrete implementations)
- Core Event publishing/handling

**Dependencies**: Boundary + Core Abstractions only
**Purpose**: Implement business flows without knowing technical details

### 4. Implementations
**Role**: Technology adapters and providers
**Contains**:
- Concrete implementations of Ports (adapters)
- Database clients and repositories
- Message queue publishers/consumers
- HTTP/gRPC clients for external APIs
- 3rd-party SDK wrappers
- Anti-Corruption Layer (ACL) for external systems
- Mappers, serializers, drivers
- **Sub-modules** (each sub-module has full 5-layer structure - fractal pattern)

**Dependencies**: Core Abstractions only
**Purpose**: Handle all technology-specific concerns; can have multiple variants; can contain nested modules

### 5. Bootstrap
**Role**: Composition root
**Contains**:
- Dependency Injection container configuration
- Service registration and wiring
- Application configuration loading
- Host/server startup logic

**Dependencies**: All layers (wires them together)
**Purpose**: Choose which concrete implementations to use; no business logic

## Fractal Architecture Pattern (F.A.P)

### What is F.A.P?

A.D.D V3 uses a **fractal (self-similar) structure** where every module at any depth has the same 5 layers.

**Pure Fractal Rules**:
- Only **6 node types total**: Module + 5 Layers (Bootstrap, Operators, Core Abstractions, Implementations, Boundary)
- Only **Implementations layer** can contain sub-modules
- Each sub-module has the exact same 5-layer structure → infinite nesting
- **No custom layer types** (no Core', Providers', etc.)

### Fractal Tree Example

```
System Root (Module)
├── Bootstrap
├── Operators
├── Core Abstractions
├── Implementations
│   ├── Module A (sub-module)
│   │   ├── Bootstrap
│   │   ├── Operators
│   │   ├── Core Abstractions
│   │   ├── Implementations
│   │   │   └── Module D (sub-sub-module)
│   │   │       └── (... same 5 layers ...)
│   │   └── Boundary
│   └── Module B
│       └── (... same 5 layers ...)
└── Boundary
```

### Path Notation

Use path notation to track position in fractal tree:
- `/` = System Root
- `/Implementations/A` = Module A (inside root's Implementations)
- `/Implementations/A/Implementations/D` = Module D (inside A's Implementations)

### Why Fractal?

1. **Self-similarity**: Same structure at all depths - learn once, apply everywhere
2. **Infinite composition**: No arbitrary nesting limits
3. **Clear boundaries**: Each module is self-contained
4. **Easy navigation**: LLMs can zoom in/out to any level using path notation

### LLM Thinking Framework

When working with A.D.D V3 code, LLMs should:

1. **Parse file path** → Determine position in fractal tree
2. **Identify current layer** → Know responsibilities and constraints
3. **Check dependency rules** → Ensure valid references only
4. **Read parent context** → Understand module purpose (README, shared-terms.md)
5. **Navigate vertically** → Move up to root, down to current level
6. **Implement with fractal awareness** → Maintain self-similar structure

### Common Fractal Mistakes

❌ **Creating custom layer types for sub-modules** (Core', Providers')
- Violates pure fractal - use same 5 layers

❌ **Assuming flat structure**
- Modules can be nested infinitely via Implementations

❌ **Missing path context**
- Always parse path to know: "Am I in root or sub-module?"

## Layer Dependency Rules

```
Valid references (compile-time):
  Bootstrap → Operators + Implementations
  Operators → Boundary + Core Abstractions
  Implementations → Core Abstractions

Forbidden:
  Operators → Implementations (direct)
  Implementations → Operators
  Implementations → Boundary
  Core Abstractions → Any other layer
  Boundary → Any other layer
```

**Key insight**: Operators and Implementations never reference each other directly. They communicate only through Ports (interfaces in Core Abstractions) resolved at runtime via DI.

## Data Flow (Standard Request)

1. External system → **Boundary** (receives DTO or Boundary Event)
2. **Boundary** → **Operators** (passes DTO)
3. **Operators** maps DTO → Entity
4. **Operators** calls Port (interface from Core Abstractions)
5. DI resolves Port → concrete adapter in **Implementations**
6. **Implementations** executes technology-specific work (DB, API, etc.)
7. **Implementations** returns result via Port contract
8. **Operators** maps result → DTO
9. **Operators** → **Boundary** (returns DTO)
10. **Boundary** → External system (response)

## Events in A.D.D

A.D.D uses two distinct event types with clear boundaries and responsibilities.

### Boundary Events
**Location**: Defined in **Boundary** layer
**Purpose**: External communication across system boundary
**Characteristics**:
- Published when system state changes (for external consumers)
- Received from external systems (webhooks, message queues, event streams)
- Versioned for backward compatibility
- Part of public API contract

**When to use**:
- System needs to notify external consumers of state changes
- Receiving events from external systems (after ACL translation)
- Publishing domain events to event bus for other microservices

### Core Events
**Location**: Defined in **Core Abstractions** layer
**Purpose**: Internal coordination between Operators and Implementations
**Characteristics**:
- Never exposed directly outside the system
- Used for decoupling Operators from Implementations
- Enable cross-module communication
- Support both strong and eventual consistency patterns

**Two sub-types**:
1. **BusinessSignal**: Meaningful business state changes
   - Versioned and stable over time
   - Examples: `Order.Approved`, `Payment.Completed`, `User.Registered`
   - Used in business workflows and Coordinator patterns
   - Long-term semantic meaning

2. **TechnicalSignal**: Operational/infrastructure signals
   - Retry triggers, telemetry, housekeeping tasks
   - Examples: `Job.RetryRequested`, `Cache.Invalidated`, `Metrics.Collected`
   - Short-term operational purpose
   - Can change frequently without business impact

### Core Event Structure (Envelope)

All Core Events must follow this standard envelope:

```json
{
  "eventName": "Domain.EventName",
  "version": 1,
  "correlationId": "00000000-0000-0000-0000-000000000000",
  "causationId": "00000000-0000-0000-0000-000000000000",
  "occurredAt": "2025-01-01T00:00:00Z",
  "payload": {
    // Event-specific data
  },
  "metadata": {
    "tenantId": "tenant-123",
    "source": "operators.OrderOperator",
    "consistency": "tgo"
  }
}
```

**Field explanations**:
- `eventName`: Domain.Action format (e.g., `Order.Created`, `Payment.Failed`)
- `version`: Integer for breaking changes; increment when payload schema changes incompatibly
- `correlationId`: Trace entire workflow across services (same for related events)
- `causationId`: ID of event that caused this event (direct parent)
- `occurredAt`: ISO 8601 timestamp when event occurred
- `payload`: Event-specific data (Entity or DTO)
- `metadata.source`: Which Operator published this event
- `metadata.consistency`: `tgo` (strong) or `coordinator` (eventual)
- `metadata.tenantId`: Multi-tenant context (if applicable)

### Event Naming Conventions

**Pattern**: `Domain.PastTenseAction`

**Good examples**:
- `Order.Created` (not Order.Create)
- `Payment.Completed` (not Payment.Complete)
- `User.PasswordResetRequested` (not User.RequestPasswordReset)
- `Invoice.Approved` (not Invoice.Approve)

**Naming rules**:
- Use PascalCase
- Past tense (event already happened)
- Describe state change, not imperative command
- Keep stable; avoid renaming (version instead)

### Event Versioning

**When to increment version**:
- Breaking payload changes (removed fields, renamed fields, type changes)
- Changed semantics (same field name but different meaning)

**Non-breaking changes** (no version bump):
- Adding new optional fields
- Adding new metadata
- Internal implementation changes

**Version handling**:
- Publishers emit current version
- Subscribers handle multiple versions (backward compatibility)
- ACL in Implementations translates between versions
- Document version changes in shared-terms.md

### Event Flow Patterns

#### Pattern 1: Operator → Implementations (via Core Event)
```
Operator publishes Core Event via IEventBus Port
  ↓
DI resolves to RabbitMQBus (Implementations)
  ↓
Implementations publishes to message queue
  ↓
Implementations subscriber receives message
  ↓
Subscriber emits Core Event back to Operator via handler
```

#### Pattern 2: External System → Internal (via ACL)
```
External webhook/message → ACL Adapter (Implementations)
  ↓
ACL translates external format to Core Event
  ↓
Core Event emitted to Operator
  ↓
Operator handles business logic
```

#### Pattern 3: Internal → External (via ACL)
```
Operator publishes Core Event
  ↓
Implementations subscriber receives Core Event
  ↓
ACL translates to Boundary Event format
  ↓
Published to external event bus/webhook
```

### Publishing & Subscribing

**Publishers** (Operators):
```typescript
// Operators/OrderOperator.ts
class OrderOperator {
  constructor(private eventBus: IEventBus) {} // Port from Core Abstractions

  async approveOrder(orderId: string): Promise<void> {
    // Business logic
    const order = await this.orderRepo.findById(orderId);
    order.approve();

    // Publish Core Event
    await this.eventBus.publish({
      eventName: "Order.Approved",
      version: 1,
      correlationId: this.context.correlationId,
      causationId: this.context.requestId,
      occurredAt: new Date().toISOString(),
      payload: { orderId, approvedBy: order.approvedBy },
      metadata: {
        source: "operators.OrderOperator",
        consistency: "tgo"
      }
    });
  }
}
```

**Subscribers** (Implementations):
```typescript
// Implementations/messaging/OrderEventSubscriber.ts
class OrderEventSubscriber {
  constructor(private messageBus: RabbitMQClient) {}

  async handleOrderApproved(event: CoreEvent<OrderApprovedPayload>): Promise<void> {
    // Technology-specific work (send email, update cache, etc.)
    await this.emailService.sendOrderConfirmation(event.payload.orderId);
  }
}
```

### Idempotency & Ordering

**Idempotency requirements**:
- Subscribers MUST be idempotent (handle duplicate events safely)
- Use `correlationId` and `causationId` to detect duplicates
- Store processed event IDs in Implementations (deduplication table)
- Return success if event already processed

**Ordering guarantees**:
- No global ordering guarantee across all events
- Partition by aggregate/entity ID for ordering within single entity
- Use event version/sequence for ordering within same aggregate
- Coordinator patterns handle ordering via explicit dependencies

**Implementation strategy**:
```typescript
// Implementations/EventDeduplicator.ts
class EventDeduplicator {
  async isProcessed(eventId: string): Promise<boolean> {
    return await this.db.exists('processed_events', eventId);
  }

  async markProcessed(eventId: string): Promise<void> {
    await this.db.insert('processed_events', {
      id: eventId,
      processedAt: new Date()
    });
  }
}
```

### Directory Structure

**Boundary Events**:
```
boundary/
  events/
    OrderCreated.event.ts
    PaymentCompleted.event.ts
```

**Core Events**:
```
core-abstractions/
  events/
    business/         # BusinessSignals
      OrderApproved.signal.ts
      UserRegistered.signal.ts
    technical/        # TechnicalSignals
      OrderRetry.signal.ts
      CacheInvalidated.signal.ts
  ports/
    IEventBus.ts      # Event publishing interface
```

**Implementations**:
```
implementations/
  messaging/
    RabbitMQBus.ts           # IEventBus implementation
    subscribers/
      OrderEventSubscriber.ts
  acl/
    ExternalEventTranslator.ts  # External ↔ Core Event translation
```

### Event Decision Tree

**When to use which event type?**

1. Is this crossing system boundary?
   - Yes → **Boundary Event**
   - No → Continue to 2

2. Is this for business workflow coordination?
   - Yes → **Core Event: BusinessSignal**
   - No → Continue to 3

3. Is this for operational/technical coordination?
   - Yes → **Core Event: TechnicalSignal**
   - No → Consider if event is needed at all

### Common Event Mistakes

❌ **Publishing Boundary Events internally**
- Use Core Events for internal coordination

❌ **Exposing Core Events to external systems**
- Translate to Boundary Events via ACL

❌ **Events with imperative names** (Order.Create)
- Use past tense (Order.Created)

❌ **Events carrying implementation details** (SQL queries, HTTP codes)
- Carry only business data in payload

❌ **Non-idempotent subscribers**
- Always implement duplicate detection

❌ **Events without correlation/causation IDs**
- Required for tracing and debugging

❌ **Breaking changes without version increment**
- Version when payload schema changes incompatibly

## Dependency Inversion in Practice

### Interface Placement
- All interfaces (Ports) declared in **Core Abstractions**
- Examples: IUserRepository, IPaymentGateway, IEmailService, IMessageBus

### Implementation Placement
- Concrete classes in **Implementations**
- Examples: PostgresUserRepository, StripePaymentGateway, SendGridEmailService, RabbitMQBus

### Operator Usage
```typescript
// Operators/UserOperator.ts
class UserOperator {
  constructor(private userRepo: IUserRepository) {} // Depends on interface

  async createUser(dto: CreateUserDto): Promise<UserDto> {
    const entity = this.mapDtoToEntity(dto);
    await this.userRepo.save(entity); // Calls interface method
    return this.mapEntityToDto(entity);
  }
}
```

### Bootstrap Wiring
```typescript
// Bootstrap/di/container.ts
container.register<IUserRepository>(
  'IUserRepository',
  PostgresUserRepository // Choose concrete implementation
);
```

**Result**: Operators work with interfaces; swap PostgreSQL → MongoDB by changing only Bootstrap; Operators unchanged.

## Anti-Corruption Layer (ACL)

### Purpose
Protect internal domain from external system complexities and changes

### Location
Always in **Implementations** layer

### Responsibilities
- Translate external data formats to internal DTOs/Entities
- Handle external protocol details (REST, SOAP, gRPC)
- Manage idempotency, versioning, outbox patterns
- Emit Core Events when receiving external events

### Pattern
```
External System → ACL Adapter (Implementations) → Core Event → Operators
Operators → Port Interface → ACL Adapter (Implementations) → External System
```

## UI Layer Integration

### Overview

UI/Frontend follows the **same 5-layer fractal pattern**. Two approaches:

1. **Separate Module** (SPA, Mobile App) - UI as independent root module
2. **Sub-Module** (SSR, Monolith) - UI nested in `/Implementations/UI`

Both maintain fractal consistency: **UI always has 5 layers**.

### Approach 1: UI as Separate Module

**Use when**: Frontend and Backend are separate deployments (SPA + REST API, Mobile + Backend)

**Structure**:
```
Frontend Module (Root)
├── Bootstrap (Router, DI, Theme, Global state)
├── Operators (ViewModel Composers, Navigation logic, UI workflows)
├── Core Abstractions (Ports: INavigationService, IDialogService, IApiClient; ViewModels; UI Events)
├── Implementations (React/Vue components, State adapters, API client, Router adapter)
└── Boundary (Screen DTOs, Analytics events, Accessibility contracts)
```

**Path examples**: `/Operators/profile-view-composer.ts`, `/Implementations/React/ProfileScreen.tsx`

### Approach 2: UI as Sub-Module

**Use when**: Frontend embedded in Backend (SSR, Blazor Server, Monolith)

**Structure**:
```
System Root
├── Implementations
│   └── UI (sub-module with 5 layers)
│       ├── Bootstrap
│       ├── Operators
│       ├── Core Abstractions
│       ├── Implementations
│       └── Boundary
```

**Path examples**: `/Implementations/UI/Operators/dashboard-composer.ts`, `/Implementations/UI/Implementations/React/Dashboard.tsx`

### UI Layer Definitions

**1. Bootstrap (UI)**: Router config, DI container, theme, global UI state setup

**2. Operators (UI)**:
- ViewModel Composers (Backend DTO → ViewModel mapping)
- Presentation Orchestrators (multi-step forms, wizards)
- Navigation Logic (route guards, breadcrumbs)

**3. Core Abstractions (UI)**:
- **Ports**: INavigationService, IDialogService, IToastService, IFormValidator, IApiClient, IStateStore
- **ViewModels**: Rich display models with computed properties, formatting
- **UI Events**: Screen.Viewed, Form.Submitted, Navigation.Completed

**4. Implementations (UI)**:
- React/Vue/Blazor components
- State management adapters (Redux/MobX implementing IStateStore)
- API client adapters (Axios/Fetch implementing IApiClient)
- Navigation adapters (React Router implementing INavigationService)

**5. Boundary (UI)**: Screen DTOs (props contracts), Display Events (analytics), Accessibility contracts

### Communication Pattern

**Frontend → Backend**:
```
UI/Implementations/API Client
  → implements IApiClient (UI/Core Abstractions)
    → called by UI/Operators (ViewModel Composers)
      → fetch Backend/Boundary/DTOs
        → map to UI/Core Abstractions/ViewModels
```

**Backend → Frontend** (SSR/embedded):
```
Backend/Operators emit Core Events
  → consumed by UI/Operators
    → update ViewModels
      → trigger UI/Implementations re-render
```

### UI Layer Decision Tree

- **Screen contract/props?** → Boundary (Screen DTOs)
- **Navigation/Dialog/Toast abstraction?** → Core Abstractions (Ports)
- **ViewModel with formatting?** → Core Abstractions (ViewModels) OR Operators (Composers)
- **Multi-step flow, navigation logic?** → Operators (Presentation Orchestrators)
- **DTO → ViewModel mapping?** → Operators (ViewModel Composers)
- **React/Vue component?** → Implementations (Component Libraries)
- **Redux/Router adapter?** → Implementations (State/Navigation Adapters)
- **DI wiring?** → Bootstrap

### Benefits

✅ **Testability**: UI Operators testable in isolation (mock Ports)
✅ **Swappable**: Replace React → Vue only changes Implementations
✅ **Fractal Consistency**: Complex UI features also have 5 layers
✅ **Dependency Inversion**: Components depend on Ports, not concrete Redux/Router

---

## Web/REST API Integration

### Overview

Web/REST API framework code (ASP.NET Controllers, Minimal API, Express, FastAPI) is **technology-specific** and belongs in **Implementations layer** as **Web Adapters**.

**Key principle**: Operators are framework-agnostic (DTO in, DTO out). Web Adapters translate between HTTP and Operators.

---

### Layer Responsibilities

**Boundary**: DTOs (request/response contracts), optional endpoint path constants

**Operators**: Business orchestration (framework-agnostic)
- Input: DTO (from Boundary)
- Output: DTO (to Boundary)
- **NEVER return framework types** (`IResult`, `IActionResult`, `Response`)
- **NEVER depend on HTTP context** (`HttpContext`, `Request`)

**Implementations/Web**: Web Adapters
- Translate HTTP requests ↔ Operator calls ↔ HTTP responses
- Framework-specific code (ASP.NET, Express, FastAPI)
- Handle HTTP concerns: status codes, headers, error mapping

**Bootstrap**: Routing/endpoint mapping, global middleware

---

### Common Mistake: Framework Code in Operators

❌ **WRONG**:
```csharp
// Operators/UserOperator.cs - WRONG!
public async Task<IResult> GetUser(string id) // ❌ Returns framework type
{
    var entity = await _repo.FindById(id);
    if (entity == null) return Results.NotFound(); // ❌ Framework code
    return Results.Ok(MapEntityToDto(entity));
}
```

**Why WRONG?**
- `IResult` is ASP.NET Core type → Operators depend on framework
- Violates: **Operators → Boundary + Core Abstractions ONLY**
- Cannot swap framework or test without framework

✅ **CORRECT**:
```csharp
// Operators/UserOperator.cs - CORRECT
public async Task<UserDto> GetUser(string id) // ✅ Returns DTO
{
    var entity = await _repo.FindById(id);
    if (entity == null) throw new UserNotFoundException(id);
    return MapEntityToDto(entity);
}

// Implementations/Web/UserWebAdapter.cs - CORRECT
public async Task<IResult> GetUser(string id)
{
    try
    {
        var dto = await _userOp.GetUser(id);
        return Results.Ok(dto);
    }
    catch (UserNotFoundException) { return Results.NotFound(); }
}
```

---

### Patterns

**Pattern 1: Inline in Bootstrap (simple)**
```csharp
// Bootstrap/WebApplicationExtensions.cs
app.MapGet("/api/users/{id}",
    async (string id, IUserOperator userOp) =>
    {
        try { return Results.Ok(await userOp.GetUser(id)); }
        catch (UserNotFoundException) { return Results.NotFound(); }
    });
```

**Pattern 2: Web Adapter class (complex)**
```csharp
// Implementations/Web/UserWebAdapter.cs
public class UserWebAdapter
{
    private readonly IUserOperator _userOp;

    public async Task<IResult> GetUser(string id)
    {
        try { return Results.Ok(await _userOp.GetUser(id)); }
        catch (UserNotFoundException) { return Results.NotFound(); }
        catch (ValidationException ex) { return Results.BadRequest(ex.Message); }
    }
}

// Bootstrap
var adapter = app.Services.GetRequiredService<UserWebAdapter>();
app.MapGet("/api/users/{id}", adapter.GetUser);
```

**Pattern 3: Controller-based**
```csharp
// Implementations/Web/Controllers/UsersController.cs
[ApiController]
[Route("api/users")]
public class UsersController : ControllerBase
{
    private readonly IUserOperator _userOp;

    [HttpGet("{id}")]
    public async Task<IActionResult> GetUser(string id)
    {
        try { return Ok(await _userOp.GetUser(id)); }
        catch (UserNotFoundException) { return NotFound(); }
    }
}
```

---

### Error Handling

**Operators throw domain exceptions**:
```csharp
// Operators/UserOperator.cs
public async Task<UserDto> GetUser(string id)
{
    var entity = await _repo.FindById(id);
    if (entity == null) throw new UserNotFoundException(id); // Domain exception
    return MapEntityToDto(entity);
}
```

**Web Adapters map exceptions to HTTP**:
```csharp
// Implementations/Web/UserWebAdapter.cs
try { return Results.Ok(await _userOp.GetUser(id)); }
catch (UserNotFoundException) { return Results.NotFound(); }
catch (ValidationException ex) { return Results.BadRequest(ex.Message); }
```

**Alternative: Global middleware** (in Bootstrap):
```csharp
// Bootstrap/Middleware/ExceptionHandlerMiddleware.cs
public async Task InvokeAsync(HttpContext context, RequestDelegate next)
{
    try { await next(context); }
    catch (UserNotFoundException ex) { context.Response.StatusCode = 404; }
    catch (ValidationException ex) { context.Response.StatusCode = 400; }
}
```

---

### Decision Tree

- **Request/response DTO?** → Boundary/DTOs
- **Business orchestration?** → Operators
- **HTTP-specific code (IResult, status codes)?** → Implementations/Web
- **Routing/endpoint mapping?** → Bootstrap
- **Global middleware?** → Bootstrap/Middleware
- **Domain exceptions?** → Core Abstractions/Exceptions

---

### Common Mistakes

❌ **Operators returning `IResult`/`IActionResult`** → Framework-agnostic required
❌ **Operators accessing `HttpContext`** → HTTP concerns in Web Adapters
❌ **Business logic in Controllers** → Thin adapters only; orchestration in Operators
❌ **Framework attributes in DTOs** (beyond serialization) → `[FromBody]`, `[Route]` belong in Web Adapters

---

## A.D.D-Extended: For Complex Domains

A.D.D V3 is sufficient for most applications. For complex domains with intricate business rules and cross-module coordination, A.D.D-Extended adds:

### Scope Modules
- Self-contained modules with full 5-layer structure
- Clear boundaries and responsibilities
- Communication only via Ports and Core Events
- Each module has `shared-terms.md` for ubiquitous language

### RuleSet & Checkpoint
- **RuleSet**: Pure function validating business rules; returns RuleReport (pass/fail + reasons)
- **Checkpoint**: Pipeline combining multiple RuleSets
- Declared in **Core Abstractions**
- Executed in **Operators** before persisting changes
- No exceptions for normal flow; structured results

### Transaction Group Operator (TGO)
- Operator managing transaction boundary for related data group
- Ensures strong consistency
- Runs Checkpoint before changes
- Operates repository Ports constrained to group "root"
- Controls commit/rollback

### Coordinator Operator
- Orchestrates multi-step flows for eventual consistency
- Coordinates via Core Events (BusinessSignals)
- Uses Compensators for rollback on failure
- Each step is independent, idempotent

### Compensator
- Describes inverse action for eventual consistency flows
- Signature declared as Port in Core Abstractions
- Pure function, infrastructure-agnostic
- Returns success/failure with reasons

### Consistency Modes
- **Strong**: Single TGO transaction; ACID guarantees
- **Eventual**: Coordinator + Core Events; eventual consistency with compensation

## Testing Strategy

### Unit Tests
- Entities (validation logic)
- Adapters in Implementations (repository, API clients)
- Mappers and serializers
- RuleSets (pure functions)

### Integration Tests
- Operator flows via Ports
- Swap real implementations with test doubles via DI
- Verify Checkpoint execution
- Test both strong and eventual consistency flows

### Contract Tests
- Verify adapters conform to Port signatures
- Translator bidirectional mapping correctness
- Compensator inverse action verification

## Migration Strategies

### New Project (from BRD)
1. Build **Boundary**: Real DTOs, service contracts, Boundary Events
2. Build **Core Abstractions**: Entities, Ports, Core Events
3. Build **Operators**: Business logic, mapping, orchestration
4. Build **Implementations**: Concrete adapters for Ports
5. Build **Bootstrap**: DI configuration, wiring

### Small Project (from zero)
1. Write minimal working program (monolith)
2. Write unit tests
3. Refactor to split into 5 layers following dependency rules

### Existing Project
1. Classify code: abstract vs concrete
2. Move to corresponding layers
3. Extract interfaces to Core Abstractions
4. Replace direct calls with Port invocations
5. Configure DI in Bootstrap

## Key Principles Summary

1. **DIP-first**: Abstractions in Core Abstractions; concretes depend on them
2. **Layer isolation**: Each layer has single responsibility; strict dependency rules
3. **Interface-driven**: Operators call only Ports, never implementations
4. **Event-based**: Core Events for internal coordination; Boundary Events for external
5. **Technology independence**: Business logic (Operators) unaware of tech details
6. **Easy replacement**: Swap DB/MQ/SDK by changing only Implementations + Bootstrap
7. **Thin entities**: Data + validation only; no business logic in entities
8. **Pure rules**: Business rules as pure functions (RuleSets); testable in isolation
9. **Clear boundaries**: ACL protects domain from external complexity
10. **Composition root**: All DI wiring in Bootstrap; nowhere else

## Common Mistakes to Avoid

❌ **Operators referencing concrete Implementations**
- Always use Ports from Core Abstractions

❌ **Business logic in Implementations**
- Implementations execute technical work only; orchestration in Operators

❌ **Technology details leaking to Operators**
- No SQL, HTTP status codes, queue names in Operators

❌ **Heavy business logic in Entities**
- Entities are thin; validation only

❌ **Circular dependencies**
- Follow strict layer dependency rules

❌ **Multiple transaction boundaries in single Operator**
- Use TGO for strong consistency or Coordinator for eventual

❌ **Direct module-to-module calls**
- Use Ports and Core Events for cross-module communication

❌ **Creating custom layer types for sub-modules** (Core', Providers')
- Violates pure fractal - every module must have exactly 5 layers

❌ **Placing sub-modules outside Implementations layer**
- Only Implementations can contain sub-modules

## When to Use A.D.D

### Use Standard A.D.D V3 when:
- Need technology replaceability (cloud agnostic, database agnostic)
- Multiple teams working on same codebase
- Long-term maintainability priority
- Frequent dependency updates
- AI-assisted development (clear structure)

### Use A.D.D-Extended when:
- Complex business rules requiring validation pipelines
- Multiple bounded contexts/modules
- Need explicit consistency control (strong vs eventual)
- Cross-module coordination with compensation
- Large-scale enterprise applications

### Consider alternatives when:
- Simple CRUD with no business logic
- Prototype/proof-of-concept (speed over structure)
- Single-developer, short-term projects
- Framework heavily prescribes architecture (may conflict)

## Relationship to Other Architectures

### vs Clean Architecture
- Similar: Layering, DIP, separation of concerns
- Different: A.D.D has 5 explicit layers; stricter dependency rules; emphasis on replaceability

### vs Hexagonal Architecture
- Similar: Ports & Adapters concept
- Different: A.D.D separates business (Operators) from abstractions (Core); explicit Bootstrap layer

### vs DDD (Domain-Driven Design)
- A.D.D-Extended can replace DDD tactical patterns
- Scope Module = Bounded Context
- TGO = Aggregate transaction boundary
- Coordinator = Process Manager/Saga
- RuleSet = Domain invariants
- Interaction Map = Context Map/ACL
- Keep DDD strategic thinking (ubiquitous language via shared-terms.md)

## Quick Reference: Layer Checklist

When adding code, ask:

- **Is this a DTO or external contract?** → Boundary
- **Is this an interface/port or domain entity?** → Core Abstractions
- **Is this business orchestration or workflow?** → Operators
- **Is this technology-specific (DB, API, MQ)?** → Implementations
- **Is this DI wiring or configuration?** → Bootstrap

When in doubt: If it's abstract (interface, model), it's Core Abstractions or Boundary. If it's concrete (implementation), it's Operators or Implementations.

---

**A.D.D V3 in one sentence**: Business flows (Operators) orchestrate via interfaces (Core Abstractions) implemented by technology adapters (Implementations), in a fractal self-similar structure that enables infinite composition and easy technology replacement.

**UI Integration**: UI/Frontend also follows the same 5-layer fractal pattern, either as a separate module (SPA, Mobile) or sub-module (SSR, Monolith), ensuring consistency from backend to presentation layer.

**Web API Integration**: Web framework code (Controllers, Minimal API handlers, Express routes) are Web Adapters in Implementations layer. Operators remain framework-agnostic (DTO in, DTO out), enabling framework swapping without changing business logic.

**Core insight**: By forcing all communication through abstractions, enforcing strict layer dependencies, and maintaining fractal self-similarity at all depths, A.D.D makes architecture evolvable, testable, technology-independent, and infinitely composable by design.
